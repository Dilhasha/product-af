<%
//TODO: check what is getAppVersionsInStages and getAppVersionsInStage
    include("/jagg/jagg.jag");
    include("/jagg/constants.jag");
    include("/jagg/config_reader.jag");



	var log = new Log("module/application/get/list.jag");

    var modManager = jagg.module("manager");
     //var modResource = jagg.module("resource");
    var modApplication = jagg.module("application");
    var carbon = require('carbon');
    var server = carbon.server;
    var appfactory = require('appFactory');
    var multitenancy = carbon.multitenancy;



    var VersionComparator = function(a, b)
    {
        return b.version.localeCompare(a.version);
    };


    var loadConfigValueFromCarbon = function(configElem)
    {
    	return server.osgiService('org.wso2.carbon.base.api.ServerConfigurationService').getFirstProperty(configElem);
    };

    
//checked - private method 
    var getAllApps = function(userName){
        // jagg.module("permission").checkUserAuthenticated();
                var appsOfUser;
                var tenantDomain=modManager.getTenantDomain() ;
                var context=multitenancy.getPrivilegedCarbonContext();
                var tenantManager= multitenancy.getTenantManager();
                try{
                    context.startTenantFlow();
                    context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
                    context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
                    appsOfUser = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationUserManagementService').getApplicaitonsOfTheUser(userName);
                    
                }finally{
                    context.endTenantFlow();
                }
        return appsOfUser;
    }
    ;
    
    var getRepoURL = function(applicationKey, version, auth)
    {
        if (auth) {
            jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        }
        
        var url;
        var tenantDomain=modManager.getTenantDomain() ;
        var context=multitenancy.getPrivilegedCarbonContext();
        var tenantManager= multitenancy.getTenantManager();
        try{
            context.startTenantFlow();
            context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
            context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
            url = server.osgiService('org.wso2.carbon.appfactory.repository.mgt.service.RepositoryManagementService').getURLForAppVersion(applicationKey,version,"");
            
        }finally{
            context.endTenantFlow();
        }
        return url;
    };

    var getAllAppsCountOfUser = function(userName)
    {
         jagg.module("permission").checkUserAuthenticated();

         // this security check is needed in case of user trying to retrieve all apps of other users.
         if (userName != jagg.getUser()) {
             var message = jagg.getUser() + ' is trying to list applications of user:' + userName;
             log.error(message);
             throw message;
         }
         try {
             var result = getAllApps(userName);
             var ns = new Namespace("http://service.mgt.application.appfactory.carbon.wso2.org");
             var elements = result.ns::["return"].text();
             return elements.length();
         } catch (e) {
             throw "Error while getting all application count of user: "+ userName;
         }
    };

    var getAllAppsOfUser = function(userName){
        // jagg.module("permission").checkUserAuthenticated();
         try {
             var result;
             result = getAllApps(userName.split('@')[0]);
             var elementsArray = new Array();
             for (var applicationKey in
            result){
                 var appInfo = convertAppInfo(result[applicationKey]);
                 if (appInfo != null) {
                     elementsArray.push(appInfo);
                 }
             }
             return stringify(elementsArray);
         } catch (e) {
             throw "Error while getting application of user" + e;
         }
  };
    
    var getAppInfo = function (applicationKey) {
        var result;
        var tenantDomain=modManager.getTenantDomain();
        var context = multitenancy.getPrivilegedCarbonContext();
        var tenantManager = multitenancy.getTenantManager();
        try {
            context.startTenantFlow();
            context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
            context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
            result = server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService').
                    getApplication(applicationKey);
        } finally {
            context.endTenantFlow();
        }
        return convertAppInfo(result);
    };

    var convertAppInfo =  function(resourceContent){
        var application = extractAppInfo(resourceContent,false);
        application.users=modApplication.getUsersOfApplication(resourceContent.id);
        session.put("APP_INFO",application);
        return application;
    }

    /*This is a light weight method and it is used only in getUserHomeInfo*/
    var convertAppInfoLightWeight =  function(resourceContent){
        var application = extractAppInfo(resourceContent,true);
        return application;
    }

    var extractAppInfo=function(resourceContent,forUserHome){

        var application={};
        if(forUserHome){
            application.key = resourceContent.applicationKey;
            application.type = resourceContent.applicationType;
        }else{
            application.key = resourceContent.id;
            application.owner = resourceContent.owner;
            application.type = resourceContent.type;

        }
        application.name = resourceContent.name;
        application.description = resourceContent.description;
        //TODO
        application.branchCount=resourceContent.branchCount;
        application.typeDisplayName = getProperty("ApplicationType." + application.type + ".Property.DisplayName");
        application.repositoryType = resourceContent.repositoryType;
        application.repositoryTypeDisplayName = getProperty("RepositoryProviderConfig." + application.repositoryType + ".Property.DisplayName");
        //TODO
        application.inProduction = false;
        return application;
    }

// This funciton get application rxt from registry and populate application object.
// This is not secured as this is calling from getAllApp method. Any caller of this
// function need to secure acess. Permission check is removed do reduce the tenant loading.
   /* var getAppInfoWithoutUserRoles = function(applicationKey)
    {
        var path = APPLICATIONS + applicationKey + APP_INFO;
        if (modResource.resourceExists(path)) {
            var resource = modResource.getResource(path);
            var resourceContent = resource.content;

            if (resourceContent. *::application. *::key.text() != undefined){
                var application = {};
                application.key = resourceContent. *::application. *::key.text();
                application.name = resourceContent. *::application. *::name.text();
                application.description = resourceContent. *::application. *::description.text();
                application.type = resourceContent. *::application. *::type.text();
                application.repositoryType = resourceContent. *::application. *::repository. *::type.text();
                return application;
            }
        }
        return null;
    }
    ;*/
//checked
    var getAllAppVersionsInStage = function(stageName, userName)
    {
        var visibilityPermissionToStage = PERMISSION_VISIBILITY_STAGE + stageName;

        var allAppVersionArray = new Array();
        var applicationList = getAllAppsOfUser(userName);
        var parsedArray = parse(applicationList);

        for (var i = 0; i < parsedArray.length; i++) {
            var application = parsedArray[i];
            var applicationKey = application.key;
            if (jagg.module("permission").isUserAccessGranted(applicationKey, visibilityPermissionToStage)) {
                var appVersions = getAppVersionsInStage(stageName, applicationKey, userName);
                if (appVersions != null) {
                    allAppVersionArray = allAppVersionArray.concat(appVersions);
                }
            }
        }

        return stringify(allAppVersionArray);
    };


    var getDeployedBuildId = function(applicationKey, version, stage){
    	return 1;
    };

//Read the application build status 
    var getLatestBuildSuccessInfo = function(applicationKey, version, stageName)
    {
        var applicatoinPath = APPLICATIONS + applicationKey;
        var path = applicatoinPath + "/" + stageName + "/" + version + "/appversion";
        var ret = {};
        ret.buildinfo = getLastBuildStatus(path);
        return ret;
    };

    var getAppVersionsInStage = function(stageName, applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        //   jagg.module("permission").checkAdminPermission();
        if (isRoleBasedPermissionAllowed == "true") {
            var hasPermissiontToStage = jagg.module("permission").hasPermissionToStage(applicationKey, stageName);
            if (!hasPermissiontToStage) {
                return null;
            }
        }
        var applicatoinPath = APPLICATIONS + applicationKey;
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        var context=multitenancy.getPrivilegedCarbonContext();
        var tenantManager= multitenancy.getTenantManager();
        try{
            context.startTenantFlow();
            context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
            context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
            artifacts =server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService').getAllVersionsOfApplication(tenantDomain, applicationKey);
        }finally{
            context.endTenantFlow();
        }
        //var artifacts =server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService').getAllVersionsOfApplication(applicationKey);
        var artifactsInStage = new Array();
        var artifactsInStageCount = 0;
        if (artifacts != undefined && artifacts.length > 0) {
            for(index in artifacts) {
                var element = artifacts[index];
                if(element['stage'] == stageName) {
                    artifactsInStage[artifactsInStageCount] = element;
                    artifactsInStageCount++;
                }
            }
        }
        var versions = getVersionInfo(applicationKey, artifactsInStage);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    }
    ;

    var getBranchInfo= function(applicationKey){
    	var result,tenantDomain=modManager.getTenantDomain();
    	var context=multitenancy.getPrivilegedCarbonContext();
    	var tenantManager= multitenancy.getTenantManager();
    	try{
    		context.startTenantFlow();
    		context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
    		context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
    		result=server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService').getBasicApplicationInfo(applicationKey);
    	}finally{
    		context.endTenantFlow();
    	}
    	return result;
    }
   /*this mehtod return the information to populate the user home
   * of the user logged in user
   * */
    var getUserHomeInfo= function(){
        var userName=modManager.getDomainlessUserName();
    	var result,tenantDomain=modManager.getTenantDomain();
    	var context=multitenancy.getPrivilegedCarbonContext();
    	var tenantManager= multitenancy.getTenantManager();
    	try{
    		context.startTenantFlow();
    		context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
    		context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
    		result=server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationInfoService').getApplicationInfoForUser(userName);

    		 var elementsArray = new Array();
             for (var applicationKey in result){
                 var appInfo = convertAppInfoLightWeight(result[applicationKey]);
                 if (appInfo != null) {
                     elementsArray.push(appInfo);
                 }
             }
             return elementsArray;
         } catch (e) {
             throw "Error while getting application of user" + e;

    	}finally{
    		context.endTenantFlow();
    	}
    	return result;
    }

    var getApplicationManagementService=function(){
        var carbon = require('carbon');
        var service;
        var tenantDomain=modManager.getTenantDomain() ;
        var context=multitenancy.getPrivilegedCarbonContext();
        var tenantManager= multitenancy.getTenantManager();
        try{
            context.startTenantFlow();
            context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
            context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
            service = carbon.server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService');
        }finally{
            context.endTenantFlow();
        }
        //return carbon.server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService');
        return service;
    }

    var getMetaDataForWarAppState = function(applicationKey, version, stage, state, type)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);

        var metaDataResult = {};

        var stageURL = getProperty("ApplicationDeployment.DeploymentStage." + stage + ".DeploymentServerURL");
        var appBaseURL = getProperty("ApplicationDeployment.DeploymentStage." + stage + ".BaseAccessUrl");
        var fileName;

        if (type == 'jaggery') {
            fileName = applicationKey + '-' + version;
            if (version == 'trunk') {
                fileName = applicationKey + '-default-SNAPSHOT';
            }
        } else {
            fileName = applicationKey + '-' + version + '.war';
            if (version == 'trunk') {
                fileName = applicationKey + '-default-SNAPSHOT.war';
            }
        }

        var ws = require("ws");
        var repoMgtService = new ws.WSRequest();
        var options = new Array();
        options.useSOAP = 1.2;

        var payload = "";

        if (state == "started") {
            options.action = "urn:getStartedWebapp";
            payload = '<xsd:getStartedWebapp xmlns:xsd="http://org.apache.axis2/xsd"><xsd:webappFileName>' + fileName + '</xsd:webappFileName></xsd:getStartedWebapp>';
        } else if (state == "stopped") {
            options.action = "urn:getStoppedWebapp";
            payload = '<xsd:getStoppedWebapp xmlns:xsd="http://org.apache.axis2/xsd"><xsd:webappFileName>' + fileName + '</xsd:webappFileName></xsd:getStoppedWebapp>';
        } else if (state == "faulty") {
            options.action = "urn:getPagedFaultyWebappsSummary";
            payload = '<xsd:getPagedFaultyWebappsSummary xmlns:xsd="http://org.apache.axis2/xsd"><xsd:webappSearchString>' + fileName + '</xsd:webappSearchString><xsd:webappType>war</xsd:webappType><xsd:pageNumber>1000</xsd:pageNumber></xsd:getPagedFaultyWebappsSummary>';
        }

        var endPoint = stageURL + "WebappAdmin";
        options["HTTPHeaders"] = [{
        	name : "Cookie", value :modManager.getBackendCookie(stageURL)
        }];

        var ns = new Namespace("http://org.apache.axis2/xsd");
        var ax2413 = new Namespace("http://mgt.webapp.carbon.wso2.org/xsd");
        try {
        	repoMgtService.open(options,endPoint, false);
        	repoMgtService.send(payload);
        } catch (e) {
        	metaDataResult.accessURLMD = "";
        	metaDataResult.baseURLMD = "";
        	metaDataResult.appStatusMD = "serverfaulty";
        	log.error("Get MetaData from " + stage + " Server. Server Problem");
        	return metaDataResult;
        }
        result = repoMgtService.responseE4X;


        var elements = result.ns::["return"];

        if (state == "started") {

            for (var buildData in
            elements){
                var buildInfo = elements[buildData];
                var appContext = buildInfo.ax2413::["context"].text();
                if (escape(appContext) == '') {
                    return getMetaDataForWarAppState(applicationKey, version, stage, "stopped", type);
                }
                if (log.isDebugEnabled()) {
                    log.debug("Get MetaData from " + stage + " Server. WebContext for " + applicationKey + "[" + version + "] is '" + appContext + "'. ");
                }
                var servletContext = buildInfo.ax2413::["servletContext"].text();

                metaDataResult.accessURLMD = escape(appContext) + escape(servletContext);
                metaDataResult.baseURLMD = appBaseURL;
                metaDataResult.appStatusMD = "started";
                break;
            }

        } else if (state == "stopped") {
            for (var buildData in elements){
                var buildInfo = elements[buildData];
                var appContext = buildInfo.ax2413::["context"].text();
                if (escape(appContext) == '') {
                    return getMetaDataForWarAppState(applicationKey, version, stage, "faulty", type);
                }
                if (log.isDebugEnabled()) {
                    log.debug("Get MetaData from " + stage + " Server. WebContext for " + applicationKey + "[" + version + "] is '" + appContext + "'. ");
                }
                var servletContext = buildInfo.ax2413::["servletContext"].text();

                metaDataResult.accessURLMD = escape(appContext) + escape(servletContext);
                metaDataResult.baseURLMD = appBaseURL;
                metaDataResult.appStatusMD = "stopped";
                break;
            }
        } else if (state == "faulty") {
            for (var buildData in
            elements){
                var buildInfo = elements[buildData];
                var webAppRoot = buildInfo.ax2413::["webapps"];
                var appContext = webAppRoot.ax2413::["context"].text();

                metaDataResult.accessURLMD = "";
                metaDataResult.baseURLMD = "";
                if (escape(appContext) != '') {
                    log.error("Get MetaData from " + stage + " Server. Application is faulty.");
                    metaDataResult.appStatusMD = "faulty";
                } else {
                    log.error("Get MetaData from " + stage + " Server. Application is Not Deployed Yet.");
                    metaDataResult.appStatusMD = "unknown";
                }
                break;
            }
        }

        return metaDataResult;

    }
    ;


    var getMetaDataForApplicationState = function(applicationKey, version, stage, state, type)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var metaDataResult = {};
        if (type == undefined || type == null || type == '') {
            var applicationInfo = getAppInfo(applicationKey);
            type = applicationInfo.type;
        }

        if (type == 'bpel' || type == 'dbs') {
            metaDataResult = getMetaDataForServiceState(applicationKey, version, stage, state, type);
        } else {
            metaDataResult = getMetaDataForWarAppState(applicationKey, version, stage, state, type);
        }
        metaDataResult.type = type;
        return metaDataResult;
    }
    ;


    var listAppsWithDetails = function()
    {
        // not secured as getAppInfo method is secured.
        var applicationKeyArray = jagg.require(jagg.getModulesDir() + "dashboard/get/list.jag").getAllApplications.apply(this, arguments);
        var applicationsArray = new Array();
        for (var _index = 0; _index < applicationKeyArray.length; _index++) {
            var _application = getAppInfo(applicationKeyArray[_index]);
            applicationsArray[_index] = _application;
        }
        return applicationsArray;
    }
    ;

//chekced
    var getAllStages = function()
    {
        jagg.module("permission").checkUserAuthenticated();
        var stages = getProperties('ApplicationDeployment.DeploymentStage');
        if (stages == null) {
            return null;
        }

        var stageArray = new Array();

        var counter = 0;
        while (stages[counter] != null) {
            stageArray[counter] = stages[counter];
            counter++;
        }

        return stringify(stageArray);
    }
    ;

//chekced
    var getBuildableStages = function()
    {
        jagg.module("permission").checkUserAuthenticated();
        var stages = getProperties('ApplicationDeployment.DeploymentStage');
        if (stages == null) {
            return null;
        }

        var stageArray = new Array();

        var counter = 0;
        try {
            while (stages[counter] != null) {
                if (getProperty('ApplicationDeployment.DeploymentStage.' + stages[counter] + '.Buildable') == "true") {
                    stageArray[stageArray.length] = stages[counter];
                }
                counter++;
            }
        } catch (e) {
            log.error("Error while getting Buildable stages from appfactory.xml \n" + e.message);
            throw "Error while getting Buildable stages";
        }

        return stringify(stageArray);
    }
    ;

//chekced
    var getAllAppVersionsInStages = function(userName)
    {
        jagg.module("permission").checkUserAuthenticated();
        var allAppVersionArray = new Array();
        var applicationList = getAllAppsOfUser(userName);
        var allStages = getAllStages();
        var parsedStages = parse(allStages);
        var parsedArray = parse(applicationList);

        for (var i = 0; i < parsedArray.length; i++) {
            var application = parsedArray[i];

            for (var j = 0; j < parsedStages.length; j++) {
                var stage = parsedStages[j];
                var hasPermissiontToStage = jagg.module("permission").hasPermissionToStage(application.key, stage);
                if (!hasPermissiontToStage) {
                    continue;
                }
                var appVersions = getAppVersionsInStage(stage, application.key, userName);
                if (appVersions != null) {
                    allAppVersionArray = allAppVersionArray.concat(appVersions);
                }
            }
        }

        return stringify(allAppVersionArray);
    }
    ;

    var getRetiredVersions = function(applicationKey, userName)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var versionsArray = new Array();
        var retiredApp = getAppVersionsInStage("Retired", applicationKey, userName, false, false, false);
        if (retiredApp != null) {
            retiredApp = parse(retiredApp);
            if (retiredApp.length > 0) {
                var application = retiredApp[0];
                var versions = application.versions;
                for (var j = 0; j < versions.length; j++) {
                    var versionInfo = versions[j];
                    versionsArray.push(versionInfo.version);
                }
            }
        }
        return versionsArray;
    }
    ;

    var getAppVersionsInStages = function(applicationKey, userName, metaDataNeed, buildableforstage, isRoleBasedPermissionAllowed)
    {
        jagg.module("permission").checkUserActionPermission(applicationKey, PERMISSION_APPLICATION_MEMBER);
        var applicatoinPath = APPLICATIONS + applicationKey;
        var artifacts;
        var tenantDomain=modManager.getTenantDomain() ;
        var context=multitenancy.getPrivilegedCarbonContext();
        var tenantManager= multitenancy.getTenantManager();
        try{
            context.startTenantFlow();
            context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
            context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
            artifacts =server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService').getAllVersionsOfApplication(modManager.getTenantDomain(),applicationKey);
        }finally{
            context.endTenantFlow();
        }
        //var artifacts =server.osgiService('org.wso2.carbon.appfactory.application.mgt.service.ApplicationManagementService').getAllVersionsOfApplication(modManager.getTenantDomain(),applicationKey);
	    var versions = getVersionInfo(applicationKey, artifacts);
        if(versions !=null) {
            return stringify(versions);
        } else {
            return null;
        }
    };

var getStage = function(applicationKey, version) {
    jagg.module("permission").checkUserAuthenticated();

    try {
        var result,tenantDomain=modManager.getTenantDomain() ;
        var context=multitenancy.getPrivilegedCarbonContext();
        var tenantManager= multitenancy.getTenantManager();
        try{
            context.startTenantFlow();
            context.getThreadLocalCarbonContext().setTenantId(tenantManager.getTenantId(tenantDomain));
            context.getThreadLocalCarbonContext().setTenantDomain(tenantDomain);
            return getApplicationManagementService().getStage(applicationKey, version);
        }finally{
            context.endTenantFlow();
        }
    } catch (e) {
        throw "Error while getting application stage of app " + applicationKey + "  :" + e;
    }
};

var getVersionInfo = function(applicationKey, artifacts) {
        //send the call to the backend
        if (artifacts != undefined && artifacts.length > 0) {
            var appVersions = new Array();
            var applicationInfo = getAppInfo(applicationKey);
            if (applicationInfo != null && applicationInfo != undefined) {
                var arrVersions = new Array();
                var k = 0;
                for (var i = 0; i < artifacts.length ; i++) {
                    var versionInfo = {};
                    var element =artifacts[i];
                    versionInfo.version = element['version'];
                    versionInfo.autoDeployment = "true";

		            versionInfo.stage = element['stage'];
                    versionInfo.isAutoBuild = element['autoBuild'] ? "true" : "false" ;
                    versionInfo.isAutoDeploy = element['autoDeploy'] ? "true" : "false";
                    versionInfo.repoURL = getRepoURL(applicationKey, versionInfo.version, true);
                    versionInfo.lastBuildResult =element['lastBuildStatus']!=null ? element['lastBuildStatus'] : '';
                    versionInfo.currentBuildStatus =element['currentBuildStatus'];
                    versionInfo.deployedBuildId = element['lastDeployedId'];
                    arrVersions[k] = versionInfo;
                    k = k + 1;
                }

                arrVersions.sort(VersionComparator);

                //////applicationInfo.stage = stageName + '';
                applicationInfo.versions = arrVersions;
                appVersions[0] = applicationInfo;
            }
	        return appVersions;
        }
        return null;
};

    var getAppCountInStage = function(applicationKey, userName)
    {
        // no need to secure as internal call is secured.
        var versionArray = new Array();
        var allStages = getAllStages();

        for (var i = 0; i < allStages.length; i++) {
            var stageName = allStages[i];
            var versionEntry = {};
            versionEntry.stage = stageName;
            var applicationList = getAllAppVersionsInStage(stageName, applicationKey, userName);

            if (applicationList == null) {
                continue;
            }

            var versionCount = 0;
            for (var j = 0; j < applicationList.length; j++) {
                var applicationInfo = applicationList[j];

                if (applicationInfo == undefined) {
                    continue;
                }
                versionCount += applicationInfo.versions.length;
            }

            versionEntry.count = versionCount;
            versionArray[i] = versionEntry;
        }
        return versionArray;
    };
    


    var getMetaDataForServiceState = function
    getMetaDataForServiceState(applicationKey, version, stage, state, type)
    {
        var metaDataResult = {};


        var stageURL = getProperty("ApplicationDeployment.DeploymentStage." + stage + ".DeploymentServerURL");
        var appBaseURL = getProperty("ApplicationDeployment.DeploymentStage." + stage + ".BaseAccessUrl");
        var serviceName;
        serviceName = applicationKey + '-' + version;
        if (version == 'trunk') {
            serviceName = applicationKey + '-SNAPSHOT';
        }
        var ws = require("ws");
        var serviceAdminService = new ws.WSRequest();
        var options = new Array();
        options.useSOAP = 1.2;
        var payload = "";

        options.action = "urn:getServiceData";
        payload = '<xsd:getServiceData xmlns:xsd="http://org.apache.axis2/xsd"><xsd:serviceName xmlns:xsd="http://org.apache.axis2/xsd">' + serviceName + '</xsd:serviceName></xsd:getServiceData>';

        var endPoint = stageURL + "ServiceAdmin";

        var ns = new Namespace("http://mgt.application.carbon.wso2.org");
        var ax2413 = new Namespace("http://mgt.application.carbon.wso2.org/xsd");
        options["HTTPHeaders"] =[{
        	name:"Cookie", value:modManager.getBackendCookie(stageURL)
        }];
        try {
        	serviceAdminService.open(options,endPoint, false);
        	serviceAdminService.send(payload);
        } catch (e) {
        	metaDataResult.accessURLMD = "";
        	metaDataResult.baseURLMD = "";
        	metaDataResult.appStatusMD = "faulty";
        	log.error("Get MetaData from " + stage + " Server. Server Problem : " + e.toString());
        	return metaDataResult;
        }
        result = serviceAdminService.responseE4X;
        var elements = result. *::["return"].*::eprs;
        var urls ="";
        for (var url in elements){	// iterate elements and only take url which is https, and prepare service URL.
        	var temUrl = elements[url].text()+"";
        	if (temUrl.indexOf("https://")==0) {	// as requested, now app types 'bpel' or 'dbs' only supports https://, TODO: based on user requirement need to develop either http or https
        		temUrl = temUrl.substring(0, temUrl.length-1);	// remove last character and append '?wsdl' to the end of URL
        		urls = temUrl + "?wsdl";
        		break;
        	}
        }
        metaDataResult.accessURLMD = urls;
        metaDataResult.baseURLMD = appBaseURL;
        metaDataResult.appStatusMD = "started";

        return metaDataResult;
    };
    
  //application icon resource read from registry
    var loadAppIcon = function (applicationKey) {
    	 try{
    	  	var serverUrl = getProperty(APPFACTORY_SERVER_URL);
    	  	var carbon = require('carbon');
    	  	var registryOsgi = new carbon.registry.Registry(serverUrl, {
    	  	   username: getProperty(ADMIN_USERNAME),
    	  	   password: getProperty(ADMIN_PASSWORD)
    	  	});
    	  	var path = "/_system/governance/repository/appicon/icon_"+ applicationKey ;
    	  	var res = registryOsgi.get(path);
    	  	return res;
      	
    	  } catch (e) {
    		  var errMsg = "Error  while loading the icon for "+ applicationKey +" application  \n" ;
            log.debug( errMsg );
            throw errMsg;
    	  }
    };
%>
